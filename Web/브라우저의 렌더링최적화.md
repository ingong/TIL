### 브라우저의 렌더링 과정

내려받은 리소스를 해석하고, 여러 계산 과정을 거쳐 콘텐츠를 보여주는 과정을 브라우저의 로드 과정이라고 합니다. HTML 문서를 파싱하여 바이트를 문자열로, 문자열을 token 으로, token 을 노드로 만들고, 이를 기반으로 DOM 을 생성합니다. 각 DOM 객체를 트리 데이터 구조로 연결해 부모-자식 관계를 생성합니다. 이 때 CSSOM 트리도 함께 구성합니다. 이 트리를 조합해 렌더트리를 구성합니다. 이 때 렌더트리는 화면에 보이는 요소들로만 구성됩니다.

다음은 레이아웃 단계입니다. 레이아웃은 뷰포트를 기준으로 노드의 정확한 위치와 크기를 계산하는 과정입니다.

다음은 페인트 단계입니다. 렌더트리의 각 노드를 화면상의 실제 픽셀로 변환합니다. 그리고 이 결과를 개별 레이어로 관리입니다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/eee97471-c750-41cc-926b-3529bbf7f83e/Untitled.png)

마지막은 Composite 단계입니다. 이는 여러 Layer 를 순서대로 합성하여 사용자에게 화면을 보여줍니다.

### 리플로우, 리페인트

브라우저의 로딩 과정 중 스타일 이후의 과정(스타일 -> 레이아웃 -> 페인트 -> 합성) 을 렌더링이라고 합니다. 스타일 단계에서 구성되는 렌더트리는 JS 에 의해 DOM 트리, CSSOM 트리가 변경될 때 재구성됩니다.

`리플로우` : 레이아웃 과정을 다시 수행하는 것, DOM 의 추가/삭제 또는 기하학적인 영향을 주는 CSS 속성값을 변경하는 경우에 발생합니다.

`리페인트` : 페인트 과정부터 다시 수행하는 것을 의미하며, 엘리먼트들의 위치와 크기를 계산할 필요가 없습니다.

Rendering Pipeline Stage Costs 를 줄여야한다.

### 렌더링 최적화

- 브라우저가 열심히 스타일을 계산해 위치를 정하고 있는데 스타일 정보를 조회하거나 변경하는 경우 (강제 동기식 레이아웃, Forced Synchronous Layout)
- 반복문과 같이 빠른 주기로 실행되는 코드에 픽셀 파이프라인을 유발하는 부분이 있는 경우 (레이아웃 스래싱, Layout Thrashing)
- 가능한한 하위 DOM 을 조작하고 스타일을 변경합니다.
- background-color, opacity 와 같이 레이아웃에는 영향을 주지 않는 스타일 속성 활용.
- 애니메이션을 활용하는 경우 requestAnimationFrame 을 사용한다.
- React.memo (이전 props 와 현재 props 의 각 필드 비교)
- 애니메이션 요소는 position: absolute, fixed 활용하기

### **로딩 속도 최적화**

- 블록 차단 리소스 최적화
  - js defer 옵션 활용
  - css preload 속성 활용하기
- 리소스 개수 줄이기
  - 압축, 난독화, 불필요 코드 제거
  - css class 활용
- 리소스 용량 줄이기
  - 모듈 번들러 활용하기
  - 이미지 레이지로딩
  - 이미지 스트라이트
