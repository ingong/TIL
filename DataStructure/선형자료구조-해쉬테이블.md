## 해쉬 테이블 (Hash Table)

해쉬 테이블은 `(key, value)` 로 데이터를 저장하는 자료구조 중 하나로, 빠르게 데이터를 검색하기 위한 용도로 사용된다. 해시 테이블은 어떻게 빠르게 데이터를 검색하는지 궁금했다. 찾아보니 내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문이라고 한다. 배열에 대한 내용을 다뤘던 문단에서 우리는 index 를 알고 있다면 O(1) 로 접근할 수 있다는 사실을 알 수 있었다. 그렇다면 배열과의 차이점은 무엇이 있을까?

해쉬 테이블이 내부적으로 배열로 구현되었기 때문에 당연히 index 를 가지며, 이 index 를 정의하는 방법에 있어서 배열과 차이가 있었다. 배열은 물리적 순서를 기반으로 논리적 순서가 결정되었다. 즉, 삽입되는 순서를 보장하면서 데이터에 대한 연속적인 메모리 공간할당이 이루어진다. 하지만 해쉬 테이블은 해쉬 함수를 통해 고유한 index 를 생성하고, 이 index 를 활용해 값을 저장하거나 검색한다. 그리고 해쉬 테이블에서는 실제 값이 저장되는 공간을 배열이 아닌, 버켓(bucket) 또는 슬롯이라고 부른다.

해쉬 테이블에서 주목할 점은 이 고유의 index 를 부여하는 과정에 있다. 이 과정은 특별한 알고리즘으로 구현되었으며, 삽입 연산 시 다른 데이터의 사이에 끼어들거나, 삭제 시 다른 데이터로 채울 필요가 없다. 따라서 연산에 의한 추가적인 비용이 발생하지 않고, 평균 시간 복잡도는 O(1) 을 가진다.

시간 복잡도면 시간 복잡도지, 평균 시간 복잡도라고 부르는 이유는 무엇일까? 이 이유는 이 특별한 알고리즘을 알아보면 자연스럽게 알 수 있게 된다. 이 특별한 알고리즘을 우리는 `hash method` 또는 `해시 함수(hash function)` 이라고 한다. 또한 이 메소드에 의해 반환된 고유의 index 를 `hashcode` 라고 한다. 해쉬 함수는 저장되는 값들의 key 값을 작은 범위의 값들로 바꿔준다. 특정한 범위가 존재한다면 당연히 key 값에 대해 `Collision(충돌)` 이 발생할 수 있다. `Collision` 이란 서로 다른 두 개의 키가 같은 `hashcode` 로 해싱되어 같은 곳에 저장할 수 없는 상황을 의미한다.

이 충돌을 최소한으로 하기 위해서는 `hash function` 을 잘 정의해야한다. 일반적으로 좋은 `hash function` 은 키의 일부분이 아닌, 키 전체를 참조하여 해쉬 값을 만들어낸다. 또한 좋은 해쉬 함수는 키가 어떤 특성을 가지고 있느냐에 대해서도 달라지게 된다. `hash function`를 무조건 1:1 로 만드는 것보다 Collision 을 최소화하는 방향으로 설계하고 발생하는 Collision 에 대비해 어떻게 대응할 것인가가 더 중요하다. 1:1 대응이 되도록 만드는 것이 거의 불가능하기도 하지만 그런 `hash function`를 만들어봤자 그건 array 와 다를바 없고 메모리를 너무 차지하게 된다.

`Collision` 이 많아질 수록 탐색에 필요한 시간복잡도가 O(1)에서 O(n)에 가까워진다. 어설픈 `hash function`는 hash 를 hash 답게 사용하지 못하도록 한다. 좋은 `hash function`를 선택하는 것은 hash table 의 성능 향상에 필수적인 것이다. 따라서 hashing 된 인덱스에 이미 다른 값이 들어 있다면 새 데이터를 저장할 다른 위치를 찾은 뒤에야 저장할 수 있는 것이다. 따라서 충돌 해결은 필수이며 그 방법들에 대해 알아보자.

### **Resolve Conflict**

해쉬 테이블에서는 충돌 문제를 분리 연결법(Separate Chaining) 과 연결 주소법(Open Addressing) 로 해결한다.

1. **개방 주소법 (Open Addressing)**

개방 주소법(Open Addressing) 은 해쉬 테이블의 공간을 활용하는 방법이다. 이 방법은 충돌이 발생하면 데이터를 저장할 장소를 찾아 해맨다. Worst Case 의 경우 비어있는 버킷을 찾지 못하고, 탐색을 시작한 위치까지 되돌아 올 수 있다. **개방 주소법**을 구현하는 방법에는 크게 3가지가 있다.

- Linear Probing: 현재의 버킷 index로부터 고정폭 만큼씩 이동하여 차례대로 검색해 비어 있는 버킷에 데이터를 저장한다.
- Quadratic Probing: 해시의 저장순서 폭을 제곱으로 저장하는 방식이다. 예를 들어 처음 충돌이 발생한 경우에는 1만큼 이동하고 그 다음 계속 충돌이 발생하면 2^2, 3^2 칸씩 옮기는 방식이다.
- Double Hashing Probing: 해시된 값을 한번 더 해싱하여 해시의 규칙성을 없애버리는 방식이다. 해시된 값을 한번 더 해싱하여 새로운 주소를 할당하기 때문에 다른 방법들보다 많은 연산을 하게 된다.

1. **분리 연결법 (Separate Chaining)**

`분리 연결법(Separate Chaining)` 은 동일한 버킷의 데이터에 대해 자료구조를 활용하고, 추가 메모리를 사용하여 다음 데이터의 주소를 저장하는 방법이다. 위의 그림과 같이 동일한 버킷으로 접근한다면 데이터들을 연결해서 해결해준다. 분리 연결법은 해시 테이블의 확장이 필요없고, 구현과 삭제가 쉽다. 하지만 데이터의 수가 많아지면 동일한 버킷에 대해 chaining 되는 데이터가 많아져, 캐시의 효율이 감소한다는 단점이 있다. 활용하는 자료구조는 링크드 리스트와 트리가 있다. 두 가지 자료구조를 활용하는 방식에 대한 설명은 다음과 같다.

- **링크드 리스트를 사용하는 방식(Linked List)**
  각각의 버킷(bucket)들을 연결리스트(Linked List)로 만들어 Collision 이 발생하면 해당 bucket 의 list 에 추가하는 방식이다. 연결 리스트의 특징을 그대로 이어받아 삭제 또는 삽입이 간단하다. 하지만 단점도 그대로 물려받아 작은 데이터들을 저장할 때 연결 리스트 자체의 오버헤드가 부담이 된다. 또 다른 특징으로는, 버킷을 계속해서 사용하는 Open Address 방식에 비해 테이블의 확장을 늦출 수 있다.
- **Tree 를 사용하는 방식 (Red-Black Tree)**
  연결 리스트를 사용할 것인가와 트리를 사용할 것인가에 대한 기준은 하나의 해시 버킷에 할당된 key-value 쌍의 개수이다. 데이터의 개수가 적다면 링크드 리스트를 사용하는 것이 맞다. 트리는 기본적으로 메모리 사용량이 많기 때문이다. 데이터 개수가 적을 때 Worst Case 를 살펴보면 트리와 링크드 리스트의 성능 상 차이가 거의 없다. 따라서 메모리 측면을 봤을 때 데이터 개수가 적을 때는 링크드 리스트를 사용한다.
- 위 두가지 방식에 대한 선택 기준은 `하나의 해쉬 버켓에 할당된 key-value 쌍의 개수` 이다. 적은 경우에는 링크드 리스트를 사용하고, 많은 경우에는 트리를 사용한다. 적고 많고의 기준은 key-value 쌍의 개수를 기준으로 6개, 8개이다. 왜 6개와 8개인지에 대한 설명은 다음과 같다.
  **_데이터가 적다는 것은 얼마나 적다는 것을 의미하는가?_** 앞에서 말했듯이 기준은 하나의 해시 버킷에 할당된 key-value 쌍의 개수이다. 이 키-값 쌍의 개수가 6 개, 8 개를 기준으로 결정한다. 기준이 두 개 인것이 이상하게 느껴질 수 있다. 7 은 어디로 갔는가? 링크드 리스트의 기준과 트리의 기준을 6 과 8 로 잡은 것은 변경하는데 소요되는 비용을 줄이기 위함이다.
  **_한 가지 상황을 가정해보자._** 해시 버킷에 **6 개** 의 key-value 쌍이 들어있었다. 그리고 하나의 값이 추가되었다. 만약 기준이 6 과 7 이라면 자료구조를 링크드 리스트에서 트리로 변경해야 한다. 그러다 바로 하나의 값이 삭제된다면 다시 트리에서 링크드 리스트로 자료구조를 변경해야 한다. 각각 자료구조로 넘어가는 기준이 1 이라면 Switching 비용이 너무 많이 필요하게 되는 것이다. 그래서 2 라는 여유를 남겨두고 기준을 잡아준 것이다. 따라서 데이터의 개수가 6 개에서 7 개로 증가했을 때는 링크드 리스트의 자료구조를 취하고 있을 것이고 8 개에서 7 개로 감소했을 때는 트리의 자료구조를 취하고 있을 것이다.

**두 가지 방식에 대해 비교를 해보면 다음과 같다.**

개방 주소법(Open Addressing) 은 분리 연결법(Separate Chaining) 에 비해 느리다. 개방 주소법의 경우 해시 버킷을 채운 밀도가 높아질수록 Worst Case 발생 빈도가 높다. 하지만 분리 연결법의 경우 보조 해시 함수를 통해 조정한다면 충돌의 확률을 낮출 수 있다.

두 방식 모두 Worst Case 에서 O(M)이다. 하지만 개방 주소법(Open Addressing)방식은 연속된 공간에 데이터를 저장하기 때문에 `분리 연결법(Separate Chaining)`에 비해 캐시 효율이 높다. 따라서 데이터의 개수가 충분히 적다면 개방 주소법(Open Addressing) 방식이 `분리 연결법(Separate Chaining)`보다 더 성능이 좋다.

또한 `분리 연결법(Separate Chaining)` 은 버킷을 계속 사용하지 않기 때문에 테이블의 확장을 늦출 수 있다.
