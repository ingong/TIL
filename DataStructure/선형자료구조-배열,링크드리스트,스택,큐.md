## 선형 자료 구조

`선형 자료 구조`는 저장되는 데이터의 전후 관계가 1 : 1 인 자료구조 라고 할 수 있다. 그러면 왜 순차적으로 나열해야하는지 궁금해졌다. 구글링을 한 결과 컴퓨터 메모리가 선형으로 배열되어 있어 구현이 쉽다는 이유를 찾을 수 있었다. 이는 충분한 이유가 됐다. 그렇다면 왜 메모리는 선형으로 배열되어있을까? 이 부분은 메모리에 대해 공부 해야한다고 생각해서 나름 심리학에서 배웠던 내용들로 추론해보았다.

당연한 이야기일지 모르지만 사람은 항상 다양한 문제에 직면하고, 이 문제를 해결한다. 이 문제를 해결하기 위해서 우리는 그 문제의 원인을 찾고, 그 원인에 대한 원인을 또 찾으려고 한다. 아마 ‘이 A의 원인은 B이고, B의 원인은 C 이고, C 의 원인은 D이다' 이런 식의 기계적인 사고를 하지는 않겠지만, 우리는 무의식적으로 아마 위와과 같은 순서로 문제의 원인을 찾았을 것이다. 다음과 같은 사고 방식을 `선형적 사고`라고 한다. 물론 모든 문제를 선형적 사고로 해결할 수는 없겠지만, 우리는 그 문제를 선형적 사고방식으로 해결하려고 했을 것이다. 메모리도 결국 사람이 만들었기 때문에 이러한 사고가 적용되지 않았을까라고 조심스럽게 추측해본다.

선형 자료 구조를 사용하는 이유가 충분했다고 가정하고, 이제는 어떻게 사용할지에 대해서 알아보도록 하자. 선형 자료구조는 크게 배열, 링크드 리스트, 스택, 큐, 해쉬 테이블이 있다. 아까 자료구조를 공부하는 방법에 대한 문단에서 데이터를 어떤 목적으로 사용하는지 정의하고, 그 자료구조를 학습하기로 했었다. 따라서 5가지 자료구조에 대해서 각각 데이터의 활용 목적이 무엇이며, 기본적으로 알아야 하는 내용에 대해서 다뤄보겠다.

## 배열 (Array)

동일한 데이터 타입의 값들을 연속적으로 저장할 때 배열을 사용한다. 인간은 선형적 사고에 대해 편안함을 느끼기 때문에 이 자료구조는 우리의 사고 방식과도 유사해서 편안한 마음을 갖고 사용할 수 있다. 배열은 논리적 저장 순서와 물리적 저장 순서가 일치한다. 따라서 우리는 인덱스로 해당 원소에 접근할 수 있다. 즉, 찾고자 하는 인덱스를 알고 있으면 O(1) 로 해당 원소에 접근할 수 있다.

접근이 용이하다는 장점이 있지만 연속적인 원소 삽입과 삭제의 경우에는 비효율적일 수 있다. 삽입의 경우 시간 복잡도가 O(1)이 지만, 연속적으로 n 의 크기만큼 삽입을 하려고 한다면 O(n) 의 시간 복잡도가 소요된다. 또한 배열의 맨 앞에 원소를 삽입하는 경우 기존에 있던 원소들의 index 를 1씩 증가시켜야하고, 시간 복잡도는 O(n) 이다.

배열의 원소를 삭제하는 경우에도 배열의 연속적인 특징이 깨지게 된다. 배열은 그 순서를 유지하기 위해 추가적인 작업을 해야 하고 비용이 발생한다. 삭제한 원소보다 큰 인덱스를 갖는 원소들을 `shift` 해줘야하고, 이 경우 시간 복잡도는 O(n) 이 된다.

## 링크드 리스트 (Linked List)

이 삽입과 삭제 시 발생하는 비효율을 해결하기 위해 등장한 자료구조가 링크드 리스트이다. 선형적으로 원소를 저장하되, 삽입과 삭제의 비효율을 감소시키기 위해 등장했다. 링크드 리스트에서 각각의 원소들은 자기 자신 다음에 어떤 원소가 존재하는지 기억하고 있다. 따라서 이 부분만 다른 값으로 바꿔주면 삭제와 삽입을 모두 O(1) 만에 해결할 수 있다.

하지만 링크드 리스트 역시 하나의 문제가 있다. 원하는 위치에 삽입하고자 한다면 위치를 탐색하는 비용이 발생한다. 원하는 위치를 탐색하는 과정에서 첫 번째 위치부터 하나씩 다 찾아야한다. 이 과정 때문에 O(n) 의 시간이 발생한다. 결국 링크드 리스트는 탐색, 삽입, 삭제 모두 O(n) 의 시간 복잡도를 갖는다. 링크드 리스트의 필요성에 대해 느끼지 못할 수 있지만, 다음 시간에 학습할 비선형 자료 구조 중 트리의 근간이 되는 자료구조이기 때문에 알아두는 편이 좋다.

배열과 링크드 리스트 모두 저장되는 데이터의 전후 관계가 1 : 1로 선형 자료구조이지만, 배열은 논리적 저장 순서와 물리적 저장 순서가 동일한 반면, 링크드 리스트는 논리적 저장 순서와 물리적 저장 순서가 다르다. 배열은 메모리 할당시 연속적인 데이터 공간 할당이 일어나지만, 링크드 리스트는 비연속적인 데이터 공간 할당이 일어난다.

## 스택 (Stack)

스택은 나중에 들어가는 원소를 우선적으로 꺼내야할 때 사용되는 자료 구조이다. Last In First Out (LIFO) 라는 키워드로 충분히 설명될 것 같다. 먼저 들어간 원소는 바닥에 깔리고, 나중에 들어가는 원소는 그 위에 차곡차곡 쌓이는 구조이다. 삽입에 대해 O(1) 이 소요되고, 마지막 원소를 삭제할 때 O(1) 이 소요된다.

## 큐 (Queue)

큐는 스택과 반대로 먼저 들어가는 원소를 우선적으로 꺼내야할 때 사용되는 자료구조다. 이는 Frist In First Out (FIFO) 라는 키워드로 설명될 수 있다.
