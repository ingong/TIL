```jsx
# HTTP
- 인터넷, 데이터, 프로토콜
- 무상태성, 비연결성

# HTTP/0.9
- 단일 라인으로 구성
- GET 메서드만 사용 가능

# HTTP/1.0
- 헤더 개념 도입
- 상태 코드
- Content-Type

# HTTP/1.1
- 커넥션 재사용
- 파이프라이닝
- Domain Sharding (여러 개의 연결을 병렬적으로 처리, But 브라우저의 한계)

# HTTP/2.0
- 응답 다중화
- 헤더의 압축
- 우선순위
- 서버 푸쉬

# HTTP/3.0
- QUIC 프로토콜 기반
- 패킷 번호를 통해 순서를 보장
- 클라이언트의 IP 가 바뀌어도 연결이 유지
```

## HTTP 란?

인터넷에서 데이터를 주고 받을 수 있게 하는 프로토콜.

무상태와 비연결성의 특징을 갖는다.

## HTTP/0.9

단일 라인으로 구성되며, 리소스에 대한 경로로 가능한 메서드는 GET 이 유일했다.

HTML 파일만 전송이 가능했으며, 상태코드가 없어 파일 내부에 문제에 대한 설명을 함께 전송

```jsx
GET / index.html;
```

## HTTP/1.0

상태코드가 응답의 시작부분에 붙어서 함께 전송되었다. 브라우저가 요청에 대한 성공과 실패를 알 수 있게 되었다. 헤더 개념이 요청과 응답 모두를 위해 도입되었다. Content-Type 을 명시함으로써 HTML 파일 이외의 파일에 대한 전송도 가능해졌다.

Connection 당 하나의 요청을 처리할 수 있다. 이는 수 많은 리소스의 요청이 발생한다면 자연스럽게 Network Latency 가 발생한다.

```jsx
GET /mypage.html HTTP/1.0
User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)

200 OK
Date: Tue, 15 Nov 1994 08:12:31 GMT
Server: CERN/3.0 libwww/2.17
Content-Type: text/html
<HTML>
	A page with an image
  <IMG SRC="/myimage.gif">
</HTML>
```

## HTTP/1.1

커넥션 재사용이 가능해졌다. 파이프라이닝이 추가되어 요청에 대한 응답이 끝나기 전에 다음 데이터를 미리 요청할 수 있게 되었다.

이를 위해 `HTTP PipeLining` 이 도입되었습니다. 이는 TCP 안에 두 개이상의 HTTP 요청을 담아 Network Latency 를 줄이는 방법입니다. 하지만 이 또한 `HOL Blocking` 문제가 발생합니다. 또한 **중복되는 헤더**와 요청마다 **쿠키**도 포함되어 전송되기 때문에 네트워크 자원이 소모되는 문제가 발생합니다.

### HTTP 1.1 의 문제 개선을 위한 노력

개발자들은 기존 HTTP 1.1 의 문제를 해결하기 위해 해결책을 도입했습니다.

- **Image Spriting**

여러 이미지 파일을 모아 한 번의 요청으로 처리하고, CSS 로 해당 이미지의 좌표값을 지정해서 사용합니다.

- **Domain Sharding**

하나의 Domain 에서 여러개의 Connection 을 생성하고 병렬로 요청을 보냅니다. 하지만 브라우저별로 Connection 개수가 제한적이였기 때문에 근본적인 해결책이 될 수 없었습니다.

- **CSS, JS 최소화**

전송되는 데이터의 용량을 줄이기 위해 이 파일들을 줄여서 해결합니다.

## HTTP/2.0

HTTP/1.1 은 하나의 TCP 연결에서 1개의 스트림만 이용이 가능하다. 요청이 동기적으로 진행되고, 헤더에 불필요하게 중복된 데이터가 존재한다.

HTTP/2.0 의 목표는 응답 다중화, 헤더의 압축, 우선순위, 서버 푸쉬이다. 이를 위해 바이너리 프레이밍 계층을 도입하였다. 이를 통해 기존 TCP 연결을 효율적으로 사용하였다.

하나의 TCP 연결에 여러 스트림을 사용하고, 요청과 응답을 병렬로 처리할 수 있게 되었다. TCP 연결이 하나이므로 3-way-handshake 오버헤드가 없고, 네트워크 가용성이 증가하여 속도 상승을 기대할 수 있었다.

- **Mutliplexed Streams**

하나의 연결에서 동시에 여러 개의 메세지를 주고 받습니다. Connection 개수가 제한적이였던 한계가 있었던 Domain Sharding 의 문제를 해결해주었습니다. Stream 으로 받기 때문에 HOL Blocking 도 발생하지 않습니다.

- **Stream Prioritization**
- **Server Push**

기존에는 하나의 요청을 클라이언트에서 응답받으면 다시 요청을 보냈어야했는데, Server Push 를 통해 클라이언트의 요청을 최소화할 수 있습니다.

- **Header Compression**

HPACK 압축방식을 통해 헤더를 압축했습니다. 또한 클라이언트와 서버에서 각각 Header Table 를 관리하고 이전에 동일한 요청이라면 Table 의 Index 만 전송하고, 변경되는 값은 Huffman Encoding 후 보냄으로써 Header 의 크기를 경량화했습니다.

## HTTP/3.0

UDP 기반의 프로토콜인 QUIC 프로토콜을 사용하여 통신하는 프로토콜

UDP 는 신뢰성과 패킷의 무결성 보장이 어렵다. 하지만 UDP 는 도화지같은 프로토콜이다. 따라서 커스터마이징이 가능하고, 신뢰성과 패킷의 무결성 보장한 QUIC 이라는 프토콜이 등장했다.

QUIC 은 고유한 패킷번호를 통해 손실 감지에 걸리는 시간을 단축시켰다. TCP 는 Sequence Number 를 기반으로 순서를 보장하였다. QUIC 은 클라이언트의 IP 가 바뀌어도 연결이 유지된다.

## Content-Type

서버에서 보내는 자원의 종류를 명시하기 위한 헤더이다.
