### 들어가며

JS 가 동적 언어라고 하는데, 동적 언어는 무엇이고, 정적 언어는 무엇일까?

### 정적 언어와 동적 언어

정적 언어는 타입(자료형)을 컴파일 시에 결정하는 언어이다. 그렇다면 컴파일은 무엇일까? MDN 에 따르면 컴파일은 주어진 언어로 작성된 컴퓨터 프로그램을 다른 언어의 동등한 프로그램으로 변환화는 과정이라고 한다. 일반적인 컴파일러는 C 와 Java 같은 고급 언어(왜 고급 언어라고 하는지는 모르겠다) 를 CPU 가 이해할 수 있는, 즉 어셈블리어와 같은 기계 언어로 변환한다.

정적 언어는 컴파일 시 타입에 대한 정보를 결정하기 때문에 속도가 빠르며, 타입 에러로 인한 문제점을 초기에 발생할 수 있기 때문에 타입의 안정성도 향상된다.

컴파일의 경우 유사한 언어 사이에서 번역하기도 하는데, 이러한 컴파일러를 트랜스 파일러 또는 크로스 컴파일러라고 한다. 예를 들면 TS 에서 JS 로 컴파일 하는 과정을 예로 들 수 있다. 사실 JS 도 컴파일러가 있는 것으로 알고 있는데, 이 부분은 나중에 JS Engine 에 대해서 학습할 때 같이 다뤄보도록 하자. TypeScript 에 대해서도 같이 다뤄보겠다.

동적 언어는 타입(자료형)을 컴파일 시 결정하는게 아니고, 실행하는 순간에 결정하는 언어이다. 이러한 언어를 인터프리터 언어라고 하며, Runtime 에 타입에 대한 결정을 하기 때문에 선택의 여지가 많지만, 실행 도중에 예상치 못한 타입이 할당되어서 TypeError 를 발생시키기도한다. 동적 언어는 다음과 같이 타입 없이 변수만 선언해서 값을 지정할 수 있다.

```tsx
num1 = 10;
name = 'InSong Lee';
```

### JS 의 타입

ECMA 표준 명세서 5.1(ES5) 에 따르면,

> - 이 명세에 수록된 알고리즘에서 사용되는 모든 값은 이 절에서 정의한 타입 목록 중 하나에 해당한다. 타입은 ECMAScript 언어 타입과 명세 타입으로 하위 분류된다.

- ECMAScript 언어를 이용하여 직접 조작하는 값들의 타입이 바로 ECMAScript 언어 타입이며, 이 언어 타입에는 Undefined, Null, Boolean, String, Number, Object 가 있다.
  >

위에서 다룬 `정적 타입형 언어`의 타입과의 정의는 꽤 다르다고 느낄 것이다. 책의 내용에 따르면 **JS 에서의 타입은 자바스크립트 엔진, 개발자 모두에게 어떤 값을 다른 값과 분별할 수 있는, 고유한 내부 특성의 집합**이라고 할 수 있다.

그렇다면 의문이 생길 수 있다. 왜 정적 언어도 아닌 JS 에서의 타입을 알아야할까?

타입별로 내재된 특성을 제대로 알고 있어야 값을 다른 타입으로 변환하는 방법을 정확히 이해할 수 있기 때문이다. 거의 모든 자바스크립트 프로그램에서 **강제변환**이 일어나기 때문에 타입을 확실하게 인지하고 사용하는 것이 중요하다.

42 라는 숫자의 위치 1에서 “2” 라는 문자를 추출하려면 “42” 라는 문자열로 먼저 강제변환해야하는 경우를 예로 들 수 있다.

### 내장 타입

JS 에는 다음 7가지 내장 타입이 있으며, typeof 연산자로 값의 타입을 알 수 있다.

- 원시 타입 : null, undefined, boolean, number, string, symbol
- 참조 타입 : object

한 가지 흥미로운 점은

```jsx
typeof null === 'object';
```

라는 점이다. 거의 20년 동안 이 버그는 끈덕지게 버텨왔고, 이제 와서 손을 댄다면 기존에 동작하던 소프트웨어가 멈춰버릴 경우가 많았다.

따라서 이 null 을 확인하기 위해서 하나의 조건을 더 추가해야했다.

```jsx
var a = null;
!a && typeof a === 'object'; // true
```

typeof 가 반환하는 문자열은 하나가 더 있다.

```jsx
typeof function a() {
  /*...*/
} === 'function'; // true
```

typeof 반환값을 본다면 function 또한 최상위 레벨의 내장 타입처럼 보이지만 실제로는 object 의 하위 타입이다. 구체적으로 설명하면 함수는 호출 가능한 객체이다.

배열 또한 하나의 객체이다. 배열은 숫자 인덱스를 가지며, length 프로퍼티가 자동으로 관리되는 등의 추가 특성을 지닌, 객체의 하위 타입이다.

```jsx
typeof [1, 2, 3] === 'object'; // true
```

### 값이 없는 vs 선언되지 않은

JS 에서 값은 타입이 있지만, 변수엔 따로 타입이 없다. 변수는 언제라도, 어떤 형태의 값이라도 가질 수 있다.

타입이 있다는 의미는 값의 내재된 특성을 정의한다고 보면 된다.

값이 없는 변수의 값은 undefined 이며, typeof 의 결과는 undefined 이다.

여기서 우리가 혼동하기 쉬운 개념은 `undefined` 와 `undeclared` 이며, 두 개념은 분명히 다르다.

- undefined : 접근 가능한 스코프에 변수가 선언되었으나, 현재 아무런 값도 할당되지 않은 상태이다.
- undeclared : 접근 가능한 스코프에 변수가 선언조차 되지 않은 상태를 의미한다.
  위 개념을 기억하고, 다음 예시를 살펴보자

```jsx
var a;

a; // undefined
b; // Reference Error: b is not defined
```

브라우저의 에러 메세지는 우리에게 혼동을 준다.

undefined 와 is not defined 둘 다 유사한 의미로 해석될 수 있다.

심지어 typeof 로 확인해보면 같은 결과가 나온다.

```jsx
var a;

typeof a; // undefined
typeof b; // undefined
```

> typeof 연산자가 선언하지 않은 식별자를 연산했을 때 “undefined”를 반환하는 것을 카일 심슨의 [“You don’t know JS”](https://www.oreilly.com/library/view/you-dont-know/9781491905159/ch01.html)에서는 특별한 안전 가드(safety guard)로 설명한다. 하지만 모던 자바스크립트 개발에서는 대부분 모듈을 사용하고 전역 변수인 플래그를 사용하지 않으므로 의도적으로 사용할 필요는 없다.

poeimaweb 에 따르면 safety guard 로 지칭하지만, 대부분 모듈을 사용하는 개발 환경에서 이를 의도적으로 사용할 필요는 없다고 한다.

사실 이 내용 뒤로는 typeof 의 안전가드에 대한 설명이다. 이 부분에 대해서는 내용을 다루기 보다는 책을 읽어보는 편이 나을 것 같다고 판단해서, 별도로 내용을 다루지는 않았다.

### 스코프

프로그래밍 언어의 기본 패러다임 중 하나는 변수에 값을 저장하고, 저장된 값을 가져오고, 저장된 값을 수정하는 것이다.

이를 통해 프로그램에서 상태를 나타날 수 있으며, 변수를 잘 활용하는 것이 중요하다.

프로그램에서 변수를 잘 활용하기 위해서는 변수 탐색, 저장, 수정을 위한 규칙이 필요하며, 이 규칙을 스코프라 한다.
