## Environment Record 로 Hoisting 이해하기

### 실행 컨텍스트

- 실행 컨텍스트는 JS 스펙을 위한 메커니즘
- 코드를 실행시키면 Call Stack 에 전역 실행 컨텍스트를 담는다
- 전역에서 함수 A 를 호출하면 함수 A 의 실행 컨텍스트가 생성되서 콜 스택에 담긴다
- 가장 최근에 추가된 실행 컨텍스트가 활성화
- 해당 컨텍스트의 마지막 라인이 실행되면 해당 실행 컨텍스트가 사라진다

```jsx
console.log(channel); // undefined

var channel = 'Netflix';

// 환경 레코드 값을 참고해서 channel 의 값을 Netflix 로 결정해낸다.
console.log(channel); // Netflix
```

### 호이스팅

- 선언 라인 전에도 에러가 나지 않고 변수를 참조할 수 있는 현상, 선언문이 마치 최상단에 끌어올려진 듯한 현상
- 왜 호이스팅이 발생할까?
  JS 엔진이 먼저 전체 코드를 스캔하면서 `변수같은 정보`를 실행컨텍스트의 Environment Record 에 미리 기록하기 때문입니다.

### 환경레코드

환경레코드는 식별자와 식별자에 바인딩된 값을 기록하는 객체입니다. 환경레코드에 변수가 저장되는 방식을 확인한다면 호이스팅의 동작방식을 이해할 수 있다.

### JS Engine 의 동작 방식

코드를 실행하면 전역 컨텍스트 한 칸을 생성해 콜스택에 넣어준다.
위 예제 코드를 실행한다면 JS 엔진은 전역 실행 컨텍스트의 환경 레코드에 channel 을 기록합니다.
해당 변수는 var 로 선언되었기 때문에 undefined 로 값을 초기화합니다.
`JS Engine 의 단계를 2가지로 나눌 수 있습니다(추가적인 공부 필요)`

- 생성 단계 : 스캔하고 준비하는 단계, 실행 컨텍스트를 생성하고, 선언문만 실행해서 환경 레코드에 기록한다.
- 실행 단계 : 선언문 외 나머지 코드 순차적 실행, Environment Record 참조하거나 업데이트

### 변수 호이스팅

- var 키워드 변수 선언

  - 선언과 초기화가 동시에 일어난다
  - 선언이란 메모리 공간을 확보하고 메모리 주소에 식별자를 연결하는 것 입니다.
  - 초기화는 암묵적으로 식별자에 undefined 값을 바인딩하는 것 입니다.

- const, let 키워드 변수 선언
  - ES6에서 추가된 const 키워드로 변수를 선언하면 식별자를 기록해놓는 선언 단계는 이루어지지만, 값을 초기화하지 않습니다.
  - 할당문 전까지는 변수에 아무런 값이 존재하지 않습니다. 따라서 유효한 값을 읽어올 수 없고, 해당 할당문이 실행되기 전에 변수를 호출하지 못하고, 이 지대를 일시적 사각지대라고 합니다.
  - 일시적 사각지대 : let 또는 const 으로 선언했을 때, 선언 이전에 식별자를 참조할 수 없는 구역 (Temporal Dead Zone)
  - 이는 `선언 라인 전에는 변수를 참조할 수 없다.` 라는 일반적인 프로그래밍 방식을 위해 언어 차원에서 보완되었다고 볼 수 있습니다.

### 함수 호이스팅

- 함수 표현식
  - 변수에 함수를 담아서 함수를 선언하는 방식으로, 변수 호이스팅과 동일하게 동작
  - var 로 선언했다면, undefined 는 호출되지 못하기 때문에 typeError 발생
  - const, let 으로 선언했다면 해당 식별자에 대한 환경 레코드의 값을 초기화하지 않으니 referenceError 발생
- 함수 선언문
  - JS 엔진이 함수 선언문으로 선언된 함수에 대해서, 함수의 선언과 동시에 완성된 함수 객체를 생성합니다. 이 생성 후에 즉시 환경레코드에 기록합니다.
  - 선언과 동시에 함수가 생성되는 것이 특징입니다.

[노션 자료](https://violet-router-2f7.notion.site/94554e577784452da54114afaf798ac4)
